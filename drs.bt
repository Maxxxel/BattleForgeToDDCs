//Definitions
struct CString
{
    int Length;
    char Text[Length];
};

struct Vector3
{
    float X;
    float Y;
    float Z;
};

struct Vector4
{
    float X;
    float Y;
    float Z;
    float W;
};

struct Vector2
{
    float X;
    float Y;
};

struct Triangle
{
    short Indices[3];
};

struct Matrix
{
    Vector4 P[4];
};


struct CGeoMesh //seems to rebuild the MeshFile, but with fewer vertices (meshfile seems to have each triangle twice anyway)
{
    int magic <fgcolor=cGreen>;
    int IndexCount <fgcolor=cGreen>;

    if (IndexCount > 0)
        Triangle Triangles[IndexCount/3] <fgcolor=cGreen>;

    int VertexCount <fgcolor=cGreen>;

    if (VertexCount > 0)
    {
        Vector4 Vertices[VertexCount] <fgcolor=cGreen>;
    }
};

struct CSkSkinInfo
{
    int Version <fgcolor=cGreen>;
    int VertexCount <fgcolor=cGreen>;

    struct _VertexWeight
    {
        float Weights[4];
        int BoneIndices[4];
    } VertexWeights[VertexCount] <fgcolor=cGreen>;
};

struct CDspMeshFile
{
    int magic;
    local int unknown = -1;
    local int MeshCount = 0;

    if(magic==1314189598){
        int tmp <hidden=true>;
        unknown = tmp;
        int tmp2 <hidden=true>;
        MeshCount = tmp2;
    } else {
        MeshCount = magic;
    }

    Vector3 BoundingBoxLowerLeftCorner1 <fgcolor=cGreen>;
    Vector3 BoundingBoxUpperRightCorner1 <fgcolor=cGreen>;

    struct sthMesh{

        int VertexCount <fgcolor=cGreen>;
        int TriangleCount <fgcolor=cGreen>;

        Triangle Triangles[TriangleCount] <fgcolor=cGreen>;


        byte MeshCount <fgcolor=cGreen>;


        struct _Mesh
        {
            int Revision <fgcolor=cGreen>;
            int VertexSize <fgcolor=cGreen>;

            if(Revision == 133121){
                struct _Vertex{
                    Vector3 vertex;
                    Vector3 vertexNormal;
                    Vector2 vertexTexture;
                } Vertex[VertexCount] <fgcolor=cGreen>;
            } else if(Revision==12288){
                struct UkVertex{
                    Vector3 uk;
                    Vector3 uk;
                } ukVertex[VertexCount] <fgcolor=cRed>;
            } else if(Revision==12){
                struct UkVertex2{
                    Vector2 uk;
                } ukVertex2[VertexCount] <fgcolor=cRed>;
            } else {
                Printf( "unknown Revision: 0x%X \n", Revision); // CDspStaticMesh::LoadVertices for further analysis

                struct UkVertex3{
                    Vector2 uk;
                } ukVertex3[VertexCount] <fgcolor=cRed>;
            }

         } Meshes[MeshCount] <optimize=false>;


        Vector3 BoundingBoxLowerLeftCorner2 <fgcolor=cGreen>; //seems like same BB as before
        Vector3 BoundingBoxUpperRightCorner2 <fgcolor=cGreen>;

        short materialID <fgcolor=cGreen>;
        int materialParameters <fgcolor=cGreen>;

        struct TextureParameter {
            int Identifier;
            
            if (Identifier == 1684432499) {
                CString ColorMap;
            } else if (Identifier == 1936745324) {
                CString ParamMap;
            } else if (Identifier == 1852992883) {
                CString NormalMap;
            } else if (Identifier == 1701738100) {
                CString EnvironmentMap;
            } else if (Identifier == 1919116143) {
                CString RefractionParamMap;
            } else if (Identifier == 1684628335) {
                CString DistortionParamMap;
            } else if (Identifier == 1668510769) {
                CString ScratchMap;
            } else if (Identifier == 1668510770) {
                CString FluidMap;
            }

            int postString;
        };

        struct TextureParameters
        {
            int Length;
            local int i = 0;
            
            for (i = 0; i < Length; i++) {
                TextureParameter textureParameter;
            };
        };

        struct ColorParameters {
            int Length; // Always 1

            struct RefractionColor {
                int Identifier;
                int R;
                int G;
                int B;
            } refractionColor[Length];
        };

        struct ScalarParameter {
            int Identifier;

            if (Identifier == 1668510769) {
                float Smoothness;
            } else if (Identifier == 1668510770) {
                float Metalness;
            } else if (Identifier == 1668510771) {
                float Reflectivity;
            } else if (Identifier == 1668510772) {
                float Emissivity;
            } else if (Identifier == 1668510773) {
                float RefractionScale;
            } else if (Identifier == 1668510774) {
                float DistortionMeshScale;
            } else if (Identifier == 1935897704) {
                float Scratch;
            } else if (Identifier == 1668510775) {
                float SpecularScale;
            } else if (Identifier == 1668510776) {
                float WindResponse;
            } else if (Identifier == 1668510777) {
                float WindHeight;
            } else if (Identifier == 1935893623) {
                float DepthWriteThreshold;
            }
        };

        struct ScalarParameters {
            int Length;
            local int i = 0;
            
            for (i = 0; i < Length; i++) {
                ScalarParameter scalarParameter;
            };
        };

        struct IntegerParameters {
            int Length; // Always 1
            int LODLevel;
        };

        struct StringParameter {
            CString Name;
        };

        struct StringParameters
        {
            int Length;
            StringParameter stringParameters[Length] <optimize=false>;
        };

        struct VectorParameter {
            int Identifier;

            if (Identifier == 1668707377) {
                Vector4 MaxFlowSpeed;
            } else if (Identifier == 1668707378) {
                Vector4 MinFlowSpeed;
            } else if (Identifier == 1668707379) {
                Vector4 FlowSpeedChange;
            } else if (Identifier == 1668707380) {
                Vector4 FlowScale;
            }
        };

        struct VectorParameters {
            int Length;
            local int i = 0;
            
            for (i = 0; i < Length; i++) {
                VectorParameter vectorParameter;
            };
        };

        if(materialParameters == -86061050){

            int sthOfMaterialCore <fgcolor=cRed>;
            int boolParamTransfer <fgcolor=cRed>;

            TextureParameters textureParameters <fgcolor=cGreen>;
            ColorParameters colorParameters <fgcolor=cGreen>;
            ScalarParameters scalarParameters <fgcolor=cGreen>;
            IntegerParameters integerParameters <fgcolor=cGreen>;
            StringParameters stringParameters <fgcolor=cGreen>;
            VectorParameters vectorParameters <fgcolor=cGreen>;
        } else if (materialParameters == -86061051 || materialParameters == -86061052) {
            int sthOfMaterialCore <fgcolor=cRed>;
            int boolParamTransfer <fgcolor=cRed>; //<- boolParamTransfer = ((unsigned int)boolParamTransfer | 1); for 0xTriangleD0004

            TextureParameters textureParameters <fgcolor=cGreen>;
            ColorParameters colorParameters <fgcolor=cGreen>;
            ScalarParameters scalarParameters <fgcolor=cGreen>;
            IntegerParameters integerParameters <fgcolor=cGreen>;
            StringParameters stringParameters <fgcolor=cGreen>;
        } else if (materialParameters == -86061053) {
            int boolParamTransfer <fgcolor=cRed>;

            TextureParameters textureParameters <fgcolor=cGreen>;
            ColorParameters colorParameters <fgcolor=cGreen>;
            ScalarParameters scalarParameters <fgcolor=cGreen>;
            IntegerParameters integerParameters <fgcolor=cGreen>;
            StringParameters stringParameters <fgcolor=cGreen>;
        } else if (materialParameters == -86061054) {
            int boolParamTransfer <fgcolor=cRed>;

            TextureParameters textureParameters <fgcolor=cGreen>;
            ColorParameters colorParameters <fgcolor=cGreen>;
            ScalarParameters scalarParameters <fgcolor=cGreen>;
            IntegerParameters integerParameters <fgcolor=cGreen>;
        } else if (materialParameters == -86061055) {
            int boolParamTransfer <fgcolor=cRed>; ////<- boolParamTransfer = ((unsigned int)boolParamTransfer | 1);

            TextureParameters textureParameters <fgcolor=cGreen>;
            ColorParameters colorParameters <fgcolor=cGreen>;
            ScalarParameters scalarParameters <fgcolor=cGreen>;
        } else {
            Printf( "unknown materialParameter: 0x%X \n", materialParameters); //CDspMaterialCore::ReadParameters for more
        }
    } meshes[MeshCount] <optimize=false>;

    //Otherwise, Vector30=(0,0,0,1) UVector3=(1,1,0,0) VVector3=(0,0,1,1)
    if(unknown >= 0){
        Vector4 Vector30 <fgcolor=cRed>;
        Vector4 UVector3 <fgcolor=cRed>;
        Vector4 VVector3 <fgcolor=cRed>;
    }
};


struct CSkSkeleton
{
    int Version <fgcolor=cGreen>;
    int Unknown1  <fgcolor=cRed>;

    int BoneMatrixCount <fgcolor=cGreen>;
    struct BoneMatrix
    {
        struct BoneVertex
        {
            float X;
            float Y;
            float Z;
            int ParentReference; //parentRef[0] = parent index, parentRef[1] = index into CSkSkeleton.dBone array, used in SKA
        } BoneVertices[4];
    } BoneMatrices[BoneMatrixCount] <fgcolor=cGreen>;

    int BoneCount <fgcolor=cGreen>;
    struct Bone
    {
        int Version;
        int Identifier;
        CString Name;
        int ChildCount;

        if (ChildCount > 0)
            int Children[ChildCount];
    } Bones[BoneCount] <fgcolor=cGreen, optimize=false>;

    Vector4 SuperParent[4] <fgcolor=cGreen>;
};

struct CDspJointMap
{
    int Version <fgcolor=cGreen>;
    int JointGroupCount <fgcolor=cGreen>;

    if (JointGroupCount > 0)
    {
        struct _JointGroup
        {
            int JointCount;
            if (JointCount > 0)
                short JointIndices[JointCount];
        } JointGroups[JointGroupCount] <fgcolor=cGreen, optimize=false>;
    }
};

struct AnimationSet
{
    CString Version <fgcolor=cGreen>;
	if (Strcmp(Version.Text, "Battleforge") != 0) Printf("\nerror bad magic AnimSet\n");
    int Count <fgcolor=cGreen>; //Should be <= 6
    if(Count>6) Printf("\nerror count >6\n");

    float DefaultRunSpeed <fgcolor=cGreen>;
    float DefaultWalkSpeed <fgcolor=cGreen>;
    int Revision <fgcolor=cGreen>;

    if (Count >= 6) //> should not happen -> Count == 6
    {
        if (Revision >= 2)
        {
            byte ModeChangeType <fgcolor=cGreen>;
            byte HoveringGround <fgcolor=cGreen>;
        }

        if (Revision >= 5)
        {
            float fly_bank_scale <fgcolor=cGreen>;
            float fly_accel_scale <fgcolor=cGreen>;
            float fly_hit_scale <fgcolor=cGreen>;
        }

        if (Revision >= 6)
            byte AlignToTerrain <fgcolor=cGreen>;
    }

    int ModeAnimationKeyCount <fgcolor=cGreen>;

    struct _ModeAnimationKey
    {
        int Type <fgcolor=cGreen>;
        CString Magic2 <fgcolor=cGreen>;
        int Unknown11 <fgcolor=cRed>;

        if (Type == 1)
        {
            int Unknown12 <fgcolor=cRed>;
            short Unknown13 <fgcolor=cRed>;
            int Unknown14 <fgcolor=cRed>;
            byte Unknown15 <fgcolor=cRed>;
            int Unknown16 <fgcolor=cRed>;
            int Unknown17 <fgcolor=cRed>;
            int Unknown18 <fgcolor=cRed>;
            byte Unknown19 <fgcolor=cRed>;
        }
        else if (Type == 2 || Type == 3 || Type == 4 || Type == 5)
        {
            int Unknown20 <fgcolor=cRed>;
            short Unknown21 <fgcolor=cRed>;
        }
        else if (Type == 6)
        {
            int Unknown22 <fgcolor=cRed>;
            short Unknown23 <fgcolor=cRed>;
            int Unknown24 <fgcolor=cRed>;
            short Unknown24 <fgcolor=cRed>;
        } else Printf("\n uk modeAnimType %d\n",Type);

        int VariantCount <fgcolor=cGreen>;

        struct AnimationSetVariant
        {
            int Unknown25 <fgcolor=cRed>;
            int weight <fgcolor=cGreen>;
            CString VariantName <fgcolor=cGreen>;

            if (Unknown25 >= 4)
            {
                float start <fgcolor=cGreen>;
                float end <fgcolor=cGreen>;
            }

            if (Unknown25 >= 5)
            {
                byte allowsIK <fgcolor=cGreen>;
            }

            if (Unknown25 >= 7)
            {
                byte Unknown31 <fgcolor=cRed>;
            }
        } Variants[VariantCount] <optimize=false>;
    } AnimationKeys[ModeAnimationKeyCount] <optimize=false>;


    if (Count >= 3)
    {
        short HasAtlas <fgcolor=cGreen>;

        if (HasAtlas >= 1)
        {
            int AtlasCount <fgcolor=cGreen>;

            struct IKAtlas{
                int identifier;
                short version;

                if(version>=1){

                    int axis;
                    int ChainOrder;

                    struct Constraint{
                        short Rev;

                        if (Rev == 1) {
                            float LeftAngle;
                            float RightAngle;
                            float LeftDampStart;
                            float RightDampStart;
                            float Dampratio;
                        }
                    } Constraints[3] <optimize=false>;
                }

                if(version>=2){
                    short PurposeFlags;
                }
            } IKAtlases[AtlasCount] <fgcolor=cGreen, optimize=false>;
        }

        if (HasAtlas >= 2)
        {
            int len1 <fgcolor=cRed>;
            struct _UnknownStruct2
            {
                int Unknown36;
                int Unknown37;
                int Unknown38;
            } Unknowns2[len1] <fgcolor=cRed>;
        }
    }


    if (Count >= 4)
    {
        short revision <fgcolor=cGreen>;

        if (revision == 2)
        {
            int AnimationMarkerCount <fgcolor=cGreen>;

            struct AnimationMarkerSet
            {
                int animID <fgcolor=cGreen>;
                CString file <fgcolor=cGreen>;
                int Unknown43 <fgcolor=cRed>;
                int MarkerCount <fgcolor=cGreen>;

                struct Marker
                {
                    int _class;
                    float time;
                    Vector3 direction;
                    Vector3 position;
                } Markers[MarkerCount] <fgcolor=cGreen>;
            } animationMarkerSets[AnimationMarkerCount] <optimize=false>;
        }
        else if (revision == 1)
        {
            int Unknown53 <fgcolor=cRed>;

            struct _UnknownStruct5
            {
                int Unknown54;
                CString Unknown55;
                int Unknown56;
                int Unknown57;

                struct _UnknownStruct6
                {
                    int Unknown58;
                    int Unknown59;
                    int Unknown60;
                    int Unknown61;
                    int Unknown62;
                } Unknowns6[Unknown57];
            } Unknowns5[Unknown53] <fgcolor=cRed, optimize=false>;
        }
    }
};



struct AnimationTimings{
    int magic <fgcolor=cGreen>;

    if(magic==1650881127){
        short version <fgcolor=cGreen>;

        struct Time{
            short len <fgcolor=cGreen>;

            struct Sth8{
                int uk;
                if(version==4 || version == 2 || version == 3){
                    int uk2;
                    short uk;
                }
                short len2;

                struct Sth9{
                    byte uk;
                    if(version==4) byte uk2;
                    short len3;
                    struct Sth10{
                        int uk[6];
                    } sth10[len3]  <optimize=false>;
                } sth9[len2] <optimize=false>;
            } sth8[len] <fgcolor=cRed, optimize=false>;
        } time <optimize=false>;


        if(version==3 || version==4) {
            struct TimeV3{
                int len;
                struct Sth7{
                    int uk[2];
                } sth7[len];
            } time3 <fgcolor=cRed, optimize=false>;
        }
    } else Printf("\nbad animTimings magic\n");

};


struct DrwResourceMeta {
    int uk[2] <fgcolor=cRed>;
    CString uk <fgcolor=cRed>;
};


struct SthSound{
	byte sthSoundFile;
	short uk;
	int uk1[5];
	CString uk2;
};

struct EffectSet{
    short type <fgcolor=cGreen>;
    CString checksum <fgcolor=cRed>;

    if(type == 10 || type == 11 || type == 12){
        if(type==10) byte uk[20] <fgcolor=cRed>;

        int len <fgcolor=cGreen>;

        struct skelEff{
            CString skelFileName <fgcolor=cGreen>;
            int len1 <fgcolor=cGreen>;

            struct WavHolder{
                float time <fgcolor=cGreen>;
                int keyframe_type <fgcolor=cGreen>;
                float minFalloff <fgcolor=cGreen>;
                float maxFalloff <fgcolor=cGreen>;
                float volume <fgcolor=cGreen>;
                float psMin <fgcolor=cGreen>;
                float psMax <fgcolor=cGreen>;
                Vector3 offset <fgcolor=cGreen>;
                byte interruptable <fgcolor=cGreen>;
                byte uk <fgcolor=cRed>;
                int len2 <fgcolor=cGreen>;

                struct Wav{
                    byte id;
                    CString wavFileName;
                } wav[len2] <fgcolor=cGreen, optimize=false>;
            } wavHolder[len1] <optimize=false>;
        } skelEffekts[len] <optimize=false>;

		short len4 <fgcolor=cRed>;
		struct Uks3{
            short uk1;
            int uk2[5];
            short uk3;
			short len6;
			SthSound sthSound2[len6] <optimize=false>;
		} uks3[len4] <fgcolor=cRed, optimize=false>;

		short len3 <fgcolor=cRed>;
		struct Uks1{
			short uk;
			int uk1[5];
			short uk2;
			short len4;
			struct Uks2{
				short uk;
				int uk1[5];
				short uk2;
				short len5;
				SthSound sthSound[len5];
			} uks2[len4] <optimize=false>;
		} uks1[len3] <fgcolor=cRed, optimize=false>;
    } else if(type == 7 || type == 8 || type == 9){//needs testing, no file with this type found
		Printf("\nwarning, untested code");
        short len6 <fgcolor=cRed>;
		struct Uks4{
			short uk;
			short len7;
			SthSound sthSound3[len7];
		} uks4[len6] <fgcolor=cRed, optimize=false>;

		short len8 <fgcolor=cRed>;
		struct Uks5{
			short uk1;
			short len9;
			SthSound sthSound4[len9];
		} uks5[len8] <fgcolor=cRed, optimize=false>;
	}
};

struct CDrwLocatorList{
    int uk;
    int version;

    if(version==4){
		int len;
		struct UK2{
            int uk1[12];
			int uk3[2];
			CString str2;
		} uk2[len]  <optimize=false>;
    } else if(version==5){
        int len;
        struct Uk1{
            int uk1[12];
            int uk2[2];
            CString str;
            int uk3;
        } uk1[len] <optimize=false>;

    } else Printf("\nnot implemented locator list version %d\n",version);
};

struct CGeoOBBTree{
	int magic <fgcolor=cGreen>;

	if(magic==1845540702){
		int id <fgcolor=cGreen>;

		if(id==1){
			byte uk[4096] <fgcolor=cRed>;
		} else if(id==2){
			byte uk[4096] <fgcolor=cRed>;
			int len1 <fgcolor=cRed>;

			struct Uks123{
				int64 uk1;
				short uk2[3];
				short uk3;
			} uks123[len1] <fgcolor=cRed>;
		} else if(id==3){
			int len2 <fgcolor=cGreen>;
            Matrix Matrices[len2] <fgcolor=cGreen>;

			int len3 <fgcolor=cGreen>;
            Triangle Triangles[len3] <fgcolor=cGreen>;
		}
	} else Printf("\n invalid obb tree file\n");
};


local string filter = "*";

//Structure
int Magic <fgcolor=cGreen>; //0xC57CF11E
if(Magic==-981667554){
	int NumberOfModels <fgcolor=cGreen>; //Must be 1; confirmed everywhere 1

	int NodeInformationOffset <fgcolor=cGreen>;
	int NodeHierarchyOffset <fgcolor=cGreen>;
	uint NodeCount <fgcolor=cGreen>; //Node count

	if (NodeCount != 0)
	{
		FSeek(NodeInformationOffset);

		struct _RootNodeInfo{
			byte zeros[16]; //confirmed zero
			int negOne <format=hex>; //confirmed
			int one;//confirmed
			int uk2;
			int zero;//confirmed zero
		} RootNodeInfo <fgcolor=cGreen>;

		struct _NodeInformation
		{
			int magic;
			int Identifier;
			int Offset;
			int Size;
			byte uk[16]; // set to 0 didnt break anything
		} NodeInformation[NodeCount-1] <fgcolor=cGreen>;


		FSeek(NodeHierarchyOffset);

		struct _RootNode
		{
			int RootIdentifier;
			int Unknown;
			CString rootName;
		} RootNode <fgcolor=cGreen>;

		local int i = 1;
		struct _Node
		{
			local int NodeIndex = i;
			int InfoIndex <fgcolor=cGreen>;
			CString Name <fgcolor=cGreen>;
			int Unknown <fgcolor=cRed>; //ChildCount?

			local int j;
			local int64 oldPosition;
			for (j = NodeCount-2; j >= 0; j--)
			{
				if (NodeInformation[j].Identifier != NodeIndex)
					continue;

				oldPosition = FTell();
				FSeek(NodeInformation[j].Offset);
				if (NodeInformation[j].Size > 0)			//CGeoPrimitiveContainer always has size 0
				{
                    if(Strcmp(Name.Text,filter)==0 || Strcmp("*",filter)==0){
						if (Strcmp(Name.Text, "CGeoMesh") == 0)
							CGeoMesh Mesh;
						else if (Strcmp(Name.Text, "CDspJointMap") == 0)
							CDspJointMap JointMap;
						else if (Strcmp(Name.Text, "CSkSkinInfo") == 0)
							CSkSkinInfo SkinInfo;
						else if (Strcmp(Name.Text, "CSkSkeleton") == 0)
							CSkSkeleton Skeleton;
						else if (Strcmp(Name.Text, "CDspMeshFile") == 0)
							CDspMeshFile MeshFile;
						else if (Strcmp(Name.Text, "AnimationSet") == 0)
							AnimationSet AnimationsSet;
						else if (Strcmp(Name.Text, "AnimationTimings") == 0)
							AnimationTimings animationTimings;
						else if (Strcmp(Name.Text, "DrwResourceMeta") == 0)
							DrwResourceMeta drwResourceMeta;
						else if (Strcmp(Name.Text, "EffectSet") == 0)
							EffectSet effectSet;
						else if (Strcmp(Name.Text, "CDrwLocatorList") == 0)
							CDrwLocatorList locList;
						else if (Strcmp(Name.Text, "CGeoOBBTree") == 0)
							CGeoOBBTree obbTree;
						else {
							Printf("\nunknown Node Name %s \n",Name.Text);
							byte Data[NodeInformation[j].Size];
						}
					}
				}
				FSeek(oldPosition);
				break;
			}

			i = i + 1;
		} Nodes[NodeCount-1] <optimize=false>;
	}
	//Printf("\n");
} else Printf("\n unknown drs magic");
